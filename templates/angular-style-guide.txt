ANGULAR 19+ CODE STYLE REQUIREMENTS:

1. COMPONENT STRUCTURE:
import { Component, signal, computed, effect, inject, input, output, viewChild } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';

@Component({
  selector: 'app-component-name',
  standalone: true,
  imports: [CommonModule, FormsModule, MatButtonModule],
  template: `
    <div class="container">
      @if (isVisible()) {
        <p>Content</p>
      }
    </div>
  `,
  styles: []
})
export class ComponentNameComponent {
  // Inject services
  private readonly router = inject(Router);
  private readonly http = inject(HttpClient);

  // Inputs
  readonly title = input.required<string>();
  readonly subtitle = input<string>('');

  // Outputs
  readonly itemClicked = output<number>();

  // Signals
  readonly count = signal(0);
  readonly items = signal<Item[]>([]);

  // Computed signals
  readonly doubleCount = computed(() => this.count() * 2);
  readonly hasItems = computed(() => this.items().length > 0);

  // ViewChild
  readonly inputRef = viewChild<ElementRef>('inputElement');

  // Lifecycle
  ngOnInit(): void {
    // Initialization logic
  }

  ngOnDestroy(): void {
    // Cleanup logic
  }

  // Effects
  constructor() {
    effect(() => {
      console.log('Count changed:', this.count());
    });
  }

  // Methods
  increment(): void {
    this.count.update(c => c + 1);
  }

  handleClick(event: MouseEvent): void {
    this.itemClicked.emit(this.count());
  }
}

2. TEMPLATE SYNTAX (Angular 19+ Control Flow):
- Conditionals:
  @if (condition) {
    <div>Content</div>
  }

  @if (condition) {
    <div>True</div>
  } @else {
    <div>False</div>
  }

  @if (condition1) {
    <div>Option 1</div>
  } @else if (condition2) {
    <div>Option 2</div>
  } @else {
    <div>Default</div>
  }

- Loops:
  @for (item of items(); track item.id) {
    <div>{{ item.name }}</div>
  }

  @for (item of items(); track $index) {
    <div>{{ item }}</div>
  }

  @for (item of items(); track item.id) {
    <div>{{ item.name }}</div>
  } @empty {
    <div>No items</div>
  }

- Switch:
  @switch (value) {
    @case ('option1') {
      <div>Option 1</div>
    }
    @case ('option2') {
      <div>Option 2</div>
    }
    @default {
      <div>Default</div>
    }
  }

- NEVER use old syntax: *ngIf, *ngFor, *ngSwitch, [ngSwitch]

3. SIGNALS:
- State: const count = signal(0)
- Read: count()
- Write: count.set(5)
- Update: count.update(c => c + 1)
- Computed: const double = computed(() => count() * 2)
- Effect: effect(() => { console.log(count()) })

4. TYPES:
- Always explicit types, NEVER 'any'
- Use interfaces or types for complex objects
- Use generics where appropriate
- Examples:
  ✓ signal<string>('hello')
  ✓ input<number>()
  ✓ output<CustomEvent>()
  ✗ signal<any>(value)
  ✗ items: any[]

5. DEPENDENCY INJECTION:
- Use inject() function:
  ✓ private readonly router = inject(Router);
  ✓ private readonly http = inject(HttpClient);
  ✗ constructor(private router: Router) {} // Old style

6. INPUTS/OUTPUTS:
- Input (required): readonly prop = input.required<string>();
- Input (optional): readonly prop = input<string>('default');
- Input (with transform): readonly prop = input(0, { transform: numberAttribute });
- Output: readonly event = output<string>();
- Emit: this.event.emit('value');

7. TEMPLATE REFERENCES:
- ViewChild: readonly element = viewChild<ElementRef>('elementRef');
- ViewChild (required): readonly element = viewChild.required<ElementRef>('elementRef');
- Access: this.element()?.nativeElement

8. FORMS:
Reactive Forms (preferred):
readonly form = signal(new FormGroup({
  name: new FormControl<string>('', Validators.required),
  email: new FormControl<string>('', [Validators.required, Validators.email])
}));

Template-driven forms:
readonly model = signal({ name: '', email: '' });

<input [(ngModel)]="model().name" />

9. HTTP REQUESTS:
readonly data = signal<Data[]>([]);
readonly loading = signal(false);
readonly error = signal<string | null>(null);

ngOnInit(): void {
  this.loading.set(true);
  this.http.get<Data[]>('/api/data')
    .subscribe({
      next: (data) => {
        this.data.set(data);
        this.loading.set(false);
      },
      error: (err) => {
        this.error.set(err.message);
        this.loading.set(false);
      }
    });
}

10. ROUTING:
- Navigate: this.router.navigate(['/path']);
- Route params:
  readonly route = inject(ActivatedRoute);
  readonly id = signal<string | null>(null);

  ngOnInit(): void {
    this.route.params.subscribe(params => {
      this.id.set(params['id']);
    });
  }

11. MATERIAL COMPONENTS:
Import required modules:
imports: [
  MatButtonModule,
  MatInputModule,
  MatFormFieldModule,
  MatIconModule,
  MatCardModule,
  MatDialogModule,
  MatSnackBarModule
]

Usage:
<button mat-raised-button color="primary">Click</button>
<mat-form-field>
  <mat-label>Name</mat-label>
  <input matInput [(ngModel)]="name()">
</mat-form-field>

12. TAILWIND CSS:
- Preserve all classes from React
- Use class binding for dynamic classes:
  [class.active]="isActive()"
  [class]="dynamicClass()"
- Combine static and dynamic:
  class="static-class" [class.dynamic]="condition()"

13. EVENT HANDLERS:
- Template: (click)="handleClick($event)"
- Method:
  handleClick(event: MouseEvent): void {
    // Handle event
  }
- Prevent default: event.preventDefault()
- Stop propagation: event.stopPropagation()

14. ASYNC OPERATIONS:
- Use RxJS operators: map, filter, switchMap, debounceTime, distinctUntilChanged
- Use async pipe in template when possible
- Example:
  readonly data$ = this.http.get<Data[]>('/api/data');

  Template:
  @for (item of data$ | async; track item.id) {
    <div>{{ item.name }}</div>
  }

15. DO NOT:
- Use 'any' type
- Use old control flow syntax (*ngIf, *ngFor)
- Use constructor for dependency injection
- Add features not in original React component
- Remove functionality
- Change business logic
- Add unnecessary comments
- Use placeholder or dummy data
- Modify Tailwind classes

16. DO:
- Use signals for all state
- Use computed for derived state
- Use effect for side effects
- Use inject() for services
- Use input() and output()
- Use @if, @for, @switch
- Preserve exact Tailwind classes
- Use explicit types everywhere
- Use Angular Material when appropriate
- Maintain same structure as React component
- Keep code repetition if present in original
- Use standalone components
- Import all required modules

17. STANDALONE COMPONENT:
Always use standalone: true
Import everything needed:
@Component({
  selector: 'app-name',
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    ReactiveFormsModule,
    MatButtonModule,
    MatInputModule,
    ChildComponent
  ],
  templateUrl: './name.component.html'
})

18. FILE STRUCTURE:
- Component: component-name.component.ts
- Template: component-name.component.html
- Styles: component-name.component.css/scss (if needed)
- For this conversion: return COMPONENT and TEMPLATE separately
